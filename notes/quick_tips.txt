async is built on a Future trait.
A future stands for a value that may not be there yet.
All futures expose a poll method.

If you want to expand macros, use cargo expand and the nightly compiler.

You can think of a mutable reference as a unique reference: the compiler guarantees to execute that they have indeed
exclusive access to that PgConnection because there cannot be two active mutable references to the same value
at the same time in the whole program. Quite neat.

Look up Arc smart pointer

Log level macros are: trace, debug, info, warn, error

{:?} is the 'std::fmt::Debug format'
{} is the 'std::fmt::Display format'

// Launch with tracing
cargo run RUST_LOG=trace

// Launch with test logs
TEST_LOG=true cargo test health_check_works | bunyan


# Build a docker image tagged as "gv_server" according to the recipe
# specified in 'Dockerfile'
docker build --tag gv_server --file Dockerfile .

# Run that image
docker run gv_server
docker run -p 8000:8000 gv_server

expose values of an object in useful ways:
Look up inner(self), inner_mut(&mut self), inner_ref(&self), AsRef<T>

?
These two blocks are equivalent

if let Err(error) = insert_subscriber(&pool, &new_subscriber)
.await
.map_err(|_| HttpResponse::InternalServerError().finish())
{
    return Err(error);
}

insert_subscriber(&pool, &new_subscriber)
.await
.map_err(|_| HttpResponse::InternalServerError().finish())?;

The ? makes it so if it hits an error, it will return that error.

debug macro
dbg!(&body)

unimplemented macros
todo!()
unimplemented!()

&str is a string slice, a just pointer to a memory buffer owned by somebody else

// Lifetimes keep track of how long references are valid for;
// the compiler makes sure that references do not stay around longer than the memory buffer they point to.
#[derive(serde::Serialize)]
#[serde(rename_all = "PascalCase")]
// Lifetime parameters always start with an apostrophe '
struct SendEmailRequest<'a> {
    from: &'a str,
    to: &'a str,
    subject: &'a str,
    html_body: &'a str,
    text_body: &'a str,
}

void async functions end with Ok(())

Due to the SQLX_OFFLINE=true in the dockerfile, schema changes must be up-to-date in the sqlx .json file.
The file can be updated with cargo sqlx prepare -- --lib